<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta/><title>Chapter 5: Network Monitoring and Analysis</title><link href="navigation.css"/><link href="document.css"/></head><body><p><a href="part5.htm">&lt; Назад</a> | <a href="index.html">Содержимое</a> | <a href="part7.htm">Далее &gt;</a></p><p><a>CHAPTER 5: NETWORK MONITORING AND ANALYSIS</a><a>&zwnj;</a></p><h2><a>Overview of Network Monitoring &amp; Analysis</a></h2><p>Network monitoring and analysis form a crucial part of the job for network administrators. They are essential for maintaining optimal network performance, ensuring network security, and minimizing downtime. Let us explore these in detail:</p><p><a>What is Network Monitoring?</a></p><p>Network monitoring is the practice of consistently overseeing a computer network for any failures or discrepancies. It is an essential IT process where all networking components like routers, switches, firewalls, servers, and VMs are monitored for fault and performance and evaluated continuously to maintain and optimize their availability. Effective network monitoring can lead to significant cost savings by preventing network disruptions and reducing downtime.</p><p><a>What is Network Analysis?</a></p><p>Network analysis refers to the method of inspecting, reviewing, and recording information about a network&#39;s data to identify trends or patterns. It helps in the diagnosis of problems and in the design of network updates. Network analysis can give insights into network performance, allowing network administrators to understand how data is being transmitted and where bottlenecks may occur.</p><p><a>Types of Network Monitoring</a></p><p>There are several types of network monitoring, each focusing on a different aspect of the network:</p><p>Performance Monitoring: This involves monitoring the performance of network elements such as routers, switches, and servers to ensure they are operating correctly and efficiently.</p><p>Fault Monitoring: This involves checking network elements for errors or failures. When a fault is detected, the system can alert network administrators so that they can rectify the problem.</p><p>Security Monitoring: This involves monitoring the network for suspicious activities or attacks. If an attack is detected, the system can alert network administrators or even take steps to mitigate the attack.</p><p>Traffic Monitoring: This involves monitoring the flow of data within the network. This can help administrators understand how network resources are being used and identify any potential bottlenecks.</p><p><a>Network Analysis Tools</a></p><p>Network administrators use a variety of tools for network analysis. These tools can provide information on a range of factors, including packet loss, throughput levels, and network latency. They can also identify which devices are connected to the network and how they are communicating with each other. Some commonly used network analysis tools include Wireshark, Ping, and traceroute.</p><p><a>Python in Network Monitoring and Analysis</a></p><p>Python, with its robust set of libraries and packages, is an ideal language for network monitoring and analysis. It has libraries like Scapy for packet analysis, Nmap for network scanning, and PySNMP for interacting with devices using the Simple Network Management Protocol (SNMP). These tools allow you to create powerful, customized network monitoring and analysis solutions.</p><p>In the following sections, we will explore in more detail how Python can be used for SNMP, network traffic monitoring, network performance monitoring, and troubleshooting.</p><h2><a>Exploring SNMP and its Python library</a></h2><p><a>Simple Network Management Protocol</a></p><p>Simple Network Management Protocol (SNMP) is a popular protocol used for managing devices in IP networks. It allows for the exchange of information between network devices, making it possible to manage and monitor these devices remotely. SNMP is used for gathering information from various network devices, such as servers, routers, switches, printers, and more, across an Internet Protocol (IP) network.</p><p>SNMP works by sending protocol data units (PDUs) to different parts of a network. SNMP- compliant devices, known as agents, store data about themselves in Management Information Bases (MIBs) and return this data to the SNMP requesters.</p><p>There are three versions of SNMP: SNMPv1, SNMPv2c, and SNMPv3. SNMPv1 is the original version of the protocol. SNMPv2c is an update that includes additional protocol operations. SNMPv3 adds security and remote configuration capabilities to the previous versions.</p><p><a>PySNMP Overview</a></p><p>PySNMP is a versatile and comprehensive Python library designed to facilitate the creation of SNMP applications. It supports all versions of the SNMP protocol (SNMPv1, SNMPv2c, and SNMPv3), making it a valuable tool for building network management software for both SNMP managers and agents. PySNMP enables users to perform various SNMP operations, such as retrieving and manipulating data from SNMP-enabled devices, allowing network administrators to monitor and manage network devices effectively.</p><p><a>Installing PySNMP</a></p><p>To get started with PySNMP, you first need to install it. You can do so using pip, which is the package installer for Python. Following are the steps to install PySNMP:</p><p>Open your command prompt (CMD) or terminal. Type the following command and press Enter:</p><p>pip            install            pysnmp                        </p><p>Wait for the installation process to complete.</p><p>Once PySNMP is installed, you can import it into your Python scripts using the following line of code:</p><p><br/></p><p>from       pysnmp.hlapi       import       *                    </p><p>In the upcoming sections, we&#39;ll explore how to use PySNMP to perform SNMP operations such as GET, SET, and WALK, which allow you to retrieve, modify, and traverse the data stored in</p><p>an SNMP agent&#39;s MIBs respectively.</p><h2><a>SNMP Operations using PySNMP</a></h2><p>let us dive into the main SNMP operations - GET, SET, and WALK. Each of these operations serves a different purpose in an SNMP-based network management system.</p><p><a>GET Operation</a></p><p>The GET operation is used to retrieve the value of a specific variable. The manager sends a GET request to an agent to retrieve the value of one or more specified object instances. When the agent receives the GET request, it will respond with the values.</p><p>Below is an example of a GET operation that retrieves the sysDescr object, which contains a description of the system:</p><p><br/></p><p>from pysnmp.hlapi import * iterator = getCmd(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysDescr&#39;, 0))</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p>from pysnmp.hlapi import * iterator = getCmd(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysDescr&#39;, 0))</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p/><p>from pysnmp.hlapi import * iterator = getCmd(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysDescr&#39;, 0))</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p><a>SET Operation</a></p><p>The SET operation is used to assign the value to a specific variable on the device. The manager sends a SET request to change the value of an object instance in the agent&#39;s MIB. This allows the manager to control the behavior of the agent.</p><p>Below is an example of a SET operation that changes the value of the sysContact object, which contains the contact information for the person responsible for the system:</p><p><br/></p><p>from pysnmp.hlapi import * iterator = setCmd(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysContact&#39;, 0), &#39;test@example.com&#39;)</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p>from pysnmp.hlapi import * iterator = setCmd(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysContact&#39;, 0), &#39;test@example.com&#39;)</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p/><p>from pysnmp.hlapi import * iterator = setCmd(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysContact&#39;, 0), &#39;test@example.com&#39;)</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p><br/></p><p><a>WALK Operation</a></p><p>The WALK operation is used to retrieve multiple object instances in a single operation. A WALK request starts at a specified object instance and then retrieves the next object instance in</p><p>the MIB until there are no more instances left. This operation is useful for exploring what data is available on an SNMP agent.</p><p>Below is an example of a WALK operation that retrieves all object instances under the system object:</p><p><br/></p><p>from pysnmp.hlapi import *</p><p>for (errorIndication, errorStatus, errorIndex, varBinds) in nextCmd( SnmpEngine(),</p><p>CommunityData(&#39;public&#39;), UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;system&#39;)), lexicographicMode=False</p><p>):</p><p>if errorIndication: print(errorIndication) break</p><p>elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>break else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p>from pysnmp.hlapi import *</p><p>for (errorIndication, errorStatus, errorIndex, varBinds) in nextCmd( SnmpEngine(),</p><p>CommunityData(&#39;public&#39;), UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;system&#39;)), lexicographicMode=False</p><p>):</p><p>if errorIndication: print(errorIndication) break</p><p>elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>break else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p/><p>from pysnmp.hlapi import *</p><p>for (errorIndication, errorStatus, errorIndex, varBinds) in nextCmd( SnmpEngine(),</p><p>CommunityData(&#39;public&#39;), UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;system&#39;)), lexicographicMode=False</p><p>):</p><p>if errorIndication: print(errorIndication) break</p><p>elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>break else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p>This script performs a WALK operation starting at the &#39;system&#39; object in the SNMPv2-MIB. The &#39;lexicographicMode=False&#39; argument stops the walk when it reaches an object outside the &#39;system&#39; subtree. The script prints each object instance it retrieves. Keep in mind that these examples are using the &#39;demo.snmplabs.com&#39; target, which is a public SNMP test server. You would replace this with the address of your own SNMP agent, and you would also replace</p><p>&#39;public&#39; with your own community string. The community string is a form of password that controls access to the SNMP agent&#39;s MIB. &#39;Public&#39; is a common default, but in a real-world situation, you should use a more secure community string.</p><p>These PySNMP examples show how you can use Python to interact with SNMP. Python and SNMP together provide a powerful tool for network management, allowing you to automate many tasks that would be time-consuming to perform manually.</p><p><a>SNMP TRAP</a></p><p>PySNMP offers advanced capabilities beyond the basic GET, SET, and WALK operations. For example, you can use PySNMP to send SNMP TRAPs or INFORMs, which are unsolicited messages from an SNMP agent to an SNMP manager. This can be useful for notifying the manager of important events or changes in the network.</p><p>Below is an example of how to send an SNMP TRAP using PySNMP:</p><p><br/></p><p>from pysnmp.hlapi import * sendNotification(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 162)), ContextData(),</p><p>&#39;trap&#39;,</p><p>NotificationType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;coldStart&#39;))</p><p>)</p><p>from pysnmp.hlapi import * sendNotification(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 162)), ContextData(),</p><p>&#39;trap&#39;,</p><p>NotificationType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;coldStart&#39;))</p><p>)</p><p/><p>from pysnmp.hlapi import * sendNotification(</p><p>SnmpEngine(), CommunityData(&#39;public&#39;),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 162)), ContextData(),</p><p>&#39;trap&#39;,</p><p>NotificationType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;coldStart&#39;))</p><p>)</p><p><br/></p><p>This script sends a coldStart trap to the manager, indicating that the SNMP agent has reinitialized itself.</p><p><a>GET Operation using SNMPv3</a></p><p>Another advanced capability of PySNMP is its support for SNMPv3, which offers enhanced security features compared to the earlier versions of SNMP. SNMPv3 supports user authentication and encryption of SNMP messages, which can protect against unauthorized access and interception of SNMP traffic.</p><p>Below is an example of how to perform a GET operation using SNMPv3 with authentication and privacy (encryption):</p><p>from pysnmp.hlapi import * iterator = getCmd(</p><p>SnmpEngine(),</p><p>UsmUserData(&#39;user&#39;, &#39;authkey&#39;, &#39;privkey&#39;, authProtocol=usmHMACSHAAuthProtocol, privProtocol=usmAesCfb128Protocol),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysDescr&#39;, 0))</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p>from pysnmp.hlapi import * iterator = getCmd(</p><p>SnmpEngine(),</p><p>UsmUserData(&#39;user&#39;, &#39;authkey&#39;, &#39;privkey&#39;, authProtocol=usmHMACSHAAuthProtocol, privProtocol=usmAesCfb128Protocol),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysDescr&#39;, 0))</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p/><p>from pysnmp.hlapi import * iterator = getCmd(</p><p>SnmpEngine(),</p><p>UsmUserData(&#39;user&#39;, &#39;authkey&#39;, &#39;privkey&#39;, authProtocol=usmHMACSHAAuthProtocol, privProtocol=usmAesCfb128Protocol),</p><p>UdpTransportTarget((&#39;demo.snmplabs.com&#39;, 161)), ContextData(),</p><p>ObjectType(ObjectIdentity(&#39;SNMPv2-MIB&#39;, &#39;sysDescr&#39;, 0))</p><p>)</p><p>errorIndication, errorStatus, errorIndex, varBinds = next(iterator) if errorIndication:</p><p>print(errorIndication) elif errorStatus:</p><p>print(&#39;%s at %s&#39; % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or &#39;?&#39;))</p><p>else:</p><p>for varBind in varBinds:</p><p>print(&#39; = &#39;.join([x.prettyPrint() for x in varBind]))</p><p>In this script, the UsmUserData object is used to specify the SNMPv3 user and the authentication and privacy keys. The authProtocol argument is used to specify the authentication protocol, and the privProtocol argument is used to specify the privacy protocol.</p><h2><a>Network Traffic Monitoring</a></h2><p>Network traffic monitoring is a critical aspect of network management. It allows network administrators to understand the volume and type of traffic on their network, identify patterns, troubleshoot issues, and plan for future capacity needs.</p><p>The first step in network traffic monitoring is to identify what you want to measure. Common metrics include:</p><p>●   Bandwidth Usage: This is the amount of data transferred over your network per unit of time. High bandwidth usage can slow down your network and affect performance.</p><p>●  Packet Loss: This is the number of packets that fail to reach their destination. Packet loss can cause interruptions in network services and degrade the quality of voice and video calls.</p><p>●   Latency: This is the amount of time it takes for a packet to travel from its source to its destination. High latency can cause delays in data transmission and affect the performance of real-time applications.</p><p>●   Jitter: This is the variation in latency over time. High jitter can cause issues with voice and video calls, as well as with some types of online games.</p><p>●   Throughput: This is the rate at which data is successfully delivered over a network connection. Low throughput can slow down file transfers and other data-intensive tasks.</p><p>Python is an excellent tool for network traffic monitoring due to its flexibility and the wide range of libraries available for networking tasks. For example, you can use the pcapy library to capture packets and the dpkt library to parse them.</p><p>Below is an example of a simple Python script that captures packets and prints out their source and destination IP addresses:</p><p><br/></p><p>import pcapy</p><p>from dpkt import ethernet, ip def print_packet(hdr, data):</p><p>packet = ethernet.Ethernet(data) if isinstance(packet.data, ip.IP):</p><p>print(&quot;Source: %s -&gt; Destination: %s&quot; % (packet.data.src, packet.data.dst))</p><p>capture = pcapy.open_live(&quot;eth0&quot;, 65536, 1, 0)</p><p>import pcapy</p><p>from dpkt import ethernet, ip def print_packet(hdr, data):</p><p>packet = ethernet.Ethernet(data) if isinstance(packet.data, ip.IP):</p><p>print(&quot;Source: %s -&gt; Destination: %s&quot; % (packet.data.src, packet.data.dst))</p><p>capture = pcapy.open_live(&quot;eth0&quot;, 65536, 1, 0)</p><p/><p>import pcapy</p><p>from dpkt import ethernet, ip def print_packet(hdr, data):</p><p>packet = ethernet.Ethernet(data) if isinstance(packet.data, ip.IP):</p><p>print(&quot;Source: %s -&gt; Destination: %s&quot; % (packet.data.src, packet.data.dst))</p><p>capture = pcapy.open_live(&quot;eth0&quot;, 65536, 1, 0)</p><p>capture.loop(0,                   print_packet)                   </p><p>In this script, pcapy.open_live is used to start packet capture on the &quot;eth0&quot; network interface. The capture.loop function is then used to process each captured packet with the print_packet function.</p><p>The print_packet function parses each packet as an Ethernet frame using dpkt.ethernet.Ethernet, then checks if the frame&#39;s payload is an IP packet. If it is, the function prints out the source and destination IP addresses of the packet. While this script provides a simple program of network traffic monitoring, real-world monitoring tasks can be much more complex. For example, you might want to aggregate statistics over time, filter for specific types of traffic, or generate alerts based on certain conditions.</p><p>Python&#39;s flexibility and the power of its networking libraries allow you to customize your monitoring scripts to fit your specific needs. You can also integrate Python scripts with other network monitoring tools to create a comprehensive monitoring solution. In addition to monitoring network traffic, Python can also be used to analyze network traffic. This involves examining captured network traffic to understand its characteristics and behavior. Network traffic analysis can help you identify trends, detect anomalies, and investigate security incidents.</p><p>For example, you might use Python to analyze network traffic for signs of a distributed denial- of-service (DDoS) attack, such as a sudden increase in traffic volume or a large number of packets from a single source. Python&#39;s data analysis libraries, such as pandas and matplotlib, can be helpful for this kind of analysis.</p><p>Below is an example of a Python script that captures packets and analyzes them to identify potential DDoS attacks:</p><p><br/></p><p>import pcapy</p><p>from dpkt import ethernet, ip import pandas as pd</p><p># Initialize a DataFrame to store packet data df = pd.DataFrame</p><p>columns=[&#39;timestamp&#39;, &#39;source&#39;, &#39;destination&#39;]) def capture_packet(hdr, data):</p><p>timestamp = hdr.getts()[0] packet = ethernet.Ethernet(data)</p><p>if isinstance(packet.data, ip.IP):</p><p>import pcapy</p><p>from dpkt import ethernet, ip import pandas as pd</p><p># Initialize a DataFrame to store packet data df = pd.DataFrame</p><p>columns=[&#39;timestamp&#39;, &#39;source&#39;, &#39;destination&#39;]) def capture_packet(hdr, data):</p><p>timestamp = hdr.getts()[0] packet = ethernet.Ethernet(data)</p><p>if isinstance(packet.data, ip.IP):</p><p/><p>import pcapy</p><p>from dpkt import ethernet, ip import pandas as pd</p><p># Initialize a DataFrame to store packet data df = pd.DataFrame</p><p>columns=[&#39;timestamp&#39;, &#39;source&#39;, &#39;destination&#39;]) def capture_packet(hdr, data):</p><p>timestamp = hdr.getts()[0] packet = ethernet.Ethernet(data)</p><p>if isinstance(packet.data, ip.IP):</p><p>source = packet.data.src destination = packet.data.dst</p><p>df.loc[len(df)] = [timestamp, source, destination] capture = pcapy.open_live(&quot;eth0&quot;, 65536, 1, 0) capture.loop(0, capture_packet)</p><p># Now that we have our data, we can start analyzing it.</p><p># Let us look for any IP addresses that are sending an unusually high number of packets.</p><p>source_counts = df[&#39;source&#39;].value_counts()</p><p>ddos_sources = source_counts[source_counts &gt; 1000] # This threshold may need to be adjusted.</p><p>if not ddos_sources.empty:</p><p>print(&quot;Potential DDoS attack detected from the following IP addresses:&quot;)</p><p>print(ddos_sources)</p><p>This script extends the previous example by storing packet data in a pandas DataFrame and using this to analyze the traffic. The capture_packet function captures each packet&#39;s timestamp and source and destination IP addresses, and adds these to the DataFrame. After capturing the data, the script counts the number of packets from each source IP address. If it finds any IP addresses that have sent more than a certain number of packets (in this case, 1000), it prints these out as potential DDoS attackers.</p><p><img src="Image_018.png"/></p><h2><a>Measuring Network Performance</a></h2><p>The process of measuring network performance characteristics such as bandwidth, packet loss, latency, jitter, and throughput can be a complex task and often requires the use of specialized network measurement tools. In Python, you can use existing libraries and system utilities to measure some of these metrics. Following are some simple programs of how you might do this:</p><p><a>Bandwidth Usage</a></p><p>Python can use the psutil library to get network IO statistics. Below is a basic script:</p><p><br/></p><p>import psutil import time</p><p>def print_network_io():</p><p>io1 = psutil.net_io_counters() time.sleep(1)</p><p>io2 = psutil.net_io_counters()</p><p>sent = io2.bytes_sent - io1.bytes_sent recv = io2.bytes_recv - io1.bytes_recv</p><p>print(&#39;Sent: {:0.2f} KB&#39;.format(sent / 1024)) print(&#39;Received: {:0.2f} KB&#39;.format(recv / 1024))</p><p>print_network_io()</p><p>import psutil import time</p><p>def print_network_io():</p><p>io1 = psutil.net_io_counters() time.sleep(1)</p><p>io2 = psutil.net_io_counters()</p><p>sent = io2.bytes_sent - io1.bytes_sent recv = io2.bytes_recv - io1.bytes_recv</p><p>print(&#39;Sent: {:0.2f} KB&#39;.format(sent / 1024)) print(&#39;Received: {:0.2f} KB&#39;.format(recv / 1024))</p><p>print_network_io()</p><p/><p>import psutil import time</p><p>def print_network_io():</p><p>io1 = psutil.net_io_counters() time.sleep(1)</p><p>io2 = psutil.net_io_counters()</p><p>sent = io2.bytes_sent - io1.bytes_sent recv = io2.bytes_recv - io1.bytes_recv</p><p>print(&#39;Sent: {:0.2f} KB&#39;.format(sent / 1024)) print(&#39;Received: {:0.2f} KB&#39;.format(recv / 1024))</p><p>print_network_io()</p><p>This script shows the amount of data sent and received over the network in the past second.</p><p><a>Packet Loss</a></p><p>Python can use the ping3 library to send ICMP echo requests and measure packet loss. Below is a basic script:</p><p><br/></p><p>from ping3 import ping, verbose_ping def packet_loss(destination, count=4):</p><p>return verbose_ping(destination, count, timeout=1)</p><p>print(packet_loss(&#39;8.8.8.8&#39;))</p><p>from ping3 import ping, verbose_ping def packet_loss(destination, count=4):</p><p>return verbose_ping(destination, count, timeout=1)</p><p>print(packet_loss(&#39;8.8.8.8&#39;))</p><p/><p>from ping3 import ping, verbose_ping def packet_loss(destination, count=4):</p><p>return verbose_ping(destination, count, timeout=1)</p><p>print(packet_loss(&#39;8.8.8.8&#39;))</p><p>This script pings a given IP address (in this case, 8.8.8.8) and returns the packet loss percentage.</p><p><a>Latency:</a></p><p>Python can use the ping3 library to measure latency. Below is a basic script:</p><p><br/></p><p>from ping3 import ping def latency(destination):</p><p>return ping(destination)</p><p>print(latency(&#39;8.8.8.8&#39;))</p><p>from ping3 import ping def latency(destination):</p><p>return ping(destination)</p><p>print(latency(&#39;8.8.8.8&#39;))</p><p/><p>from ping3 import ping def latency(destination):</p><p>return ping(destination)</p><p>print(latency(&#39;8.8.8.8&#39;))</p><p>This script pings a given IP address and returns the round-trip time in milliseconds.</p><p><a>Jitter</a></p><p>Python can use the ping3 library to measure jitter. Below is a basic script:</p><p><br/></p><p>from ping3 import ping import numpy as np</p><p>def jitter(destination, count=4):</p><p>delays = [ping(destination) for _ in range(count)] return np.std(delays)</p><p>print(jitter(&#39;8.8.8.8&#39;))</p><p>from ping3 import ping import numpy as np</p><p>def jitter(destination, count=4):</p><p>delays = [ping(destination) for _ in range(count)] return np.std(delays)</p><p>print(jitter(&#39;8.8.8.8&#39;))</p><p/><p>from ping3 import ping import numpy as np</p><p>def jitter(destination, count=4):</p><p>delays = [ping(destination) for _ in range(count)] return np.std(delays)</p><p>print(jitter(&#39;8.8.8.8&#39;))</p><p>This script sends several ICMP echo requests to a given IP address and calculates the standard deviation of the round-trip times.</p><p><a>Throughput</a></p><p>Measuring throughput can be complex, depending on the specific requirements. However, a simple way is to measure the amount of data that can be sent to a server in a given amount of time. This would typically involve setting up a server to receive the data and a client to send it. This script is an example of how you could measure throughput:</p><p><br/></p><p>import time import socket</p><p>def measure_throughput(server_ip, server_port, duration):</p><p>import time import socket</p><p>def measure_throughput(server_ip, server_port, duration):</p><p/><p>import time import socket</p><p>def measure_throughput(server_ip, server_port, duration):</p><p><img src="Image_019.png"/></p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>client_socket.connect((server_ip, server_port)) start = time.time()</p><p>data = b&#39;x&#39; * 1024 # 1 KB of data while time.time() - start &lt; duration:</p><p>client_socket.send(data) end = time.time() client_socket.close()</p><p>throughput = 1024 * duration / (end - start)</p><p>print(f&#39;Throughput: {throughput} KB/s&#39;)</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>client_socket.connect((server_ip, server_port)) start = time.time()</p><p>data = b&#39;x&#39; * 1024 # 1 KB of data while time.time() - start &lt; duration:</p><p>client_socket.send(data) end = time.time() client_socket.close()</p><p>throughput = 1024 * duration / (end - start)</p><p>print(f&#39;Throughput: {throughput} KB/s&#39;)</p><p/><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>client_socket.connect((server_ip, server_port)) start = time.time()</p><p>data = b&#39;x&#39; * 1024 # 1 KB of data while time.time() - start &lt; duration:</p><p>client_socket.send(data) end = time.time() client_socket.close()</p><p>throughput = 1024 * duration / (end - start)</p><p>print(f&#39;Throughput: {throughput} KB/s&#39;)</p><h2><a>Analyzing Network Performance</a></h2><p>Analyzing network performance involves interpreting data collected from network monitoring tools to evaluate the efficiency and effectiveness of the network. In Python, you can use libraries such as Matplotlib, Pandas, and Numpy to analyze and visualize network performance data.</p><p>The given below is a simplified example of how you might analyze network performance data using Python. In the below example, we&#39;ll assume that we have a CSV file containing network latency data that we&#39;ve collected, and we want to analyze this data to identify any trends or issues.</p><p>The CSV file (named latency_data.csv) has the following format:</p><p><br/></p><table><tr><td><p>time</p></td><td><p>latency</p></td></tr><tr><td><p>1620321000</p></td><td><p>25.6</p></td></tr><tr><td><p>1620321060</p></td><td><p>27.1</p></td></tr><tr><td><p>1620321120</p></td><td><p>26.4</p></td></tr></table><p><a>Load the Data</a></p><p>We can use the pandas library to load this data into a DataFrame, which is a type of data structure provided by pandas that makes it easy to analyze structured data.</p><p><br/></p><p>import pandas as pd</p><p># Load the CSV data into a pandas DataFrame df = pd.read_csv(&#39;latency_data.csv&#39;)</p><p># Convert the &#39;time&#39; column to datetime format df[&#39;time&#39;] = pd.to_datetime(df[&#39;time&#39;], unit=&#39;s&#39;) # Set the &#39;time&#39; column as the index df.set_index(&#39;time&#39;, inplace=True)</p><p>print(df.head())</p><p>import pandas as pd</p><p># Load the CSV data into a pandas DataFrame df = pd.read_csv(&#39;latency_data.csv&#39;)</p><p># Convert the &#39;time&#39; column to datetime format df[&#39;time&#39;] = pd.to_datetime(df[&#39;time&#39;], unit=&#39;s&#39;) # Set the &#39;time&#39; column as the index df.set_index(&#39;time&#39;, inplace=True)</p><p>print(df.head())</p><p/><p>import pandas as pd</p><p># Load the CSV data into a pandas DataFrame df = pd.read_csv(&#39;latency_data.csv&#39;)</p><p># Convert the &#39;time&#39; column to datetime format df[&#39;time&#39;] = pd.to_datetime(df[&#39;time&#39;], unit=&#39;s&#39;) # Set the &#39;time&#39; column as the index df.set_index(&#39;time&#39;, inplace=True)</p><p>print(df.head())</p><p><br/></p><p><a>Analyze the Data</a></p><p>Once the data is loaded into a DataFrame, we can use the various functions provided by pandas to analyze the data. For example, we can calculate the average latency, the maximum latency, and the minimum latency.</p><p># Calculate the average latency avg_latency = df[&#39;latency&#39;].mean() print(f&#39;Average latency: {avg_latency} ms&#39;) # Calculate the maximum latency max_latency = df[&#39;latency&#39;].max()</p><p>print(f&#39;Maximum latency: {max_latency} ms&#39;) # Calculate the minimum latency</p><p>min_latency = df[&#39;latency&#39;].min()</p><p>print(f&#39;Minimum latency: {min_latency} ms&#39;)</p><p># Calculate the average latency avg_latency = df[&#39;latency&#39;].mean() print(f&#39;Average latency: {avg_latency} ms&#39;) # Calculate the maximum latency max_latency = df[&#39;latency&#39;].max()</p><p>print(f&#39;Maximum latency: {max_latency} ms&#39;) # Calculate the minimum latency</p><p>min_latency = df[&#39;latency&#39;].min()</p><p>print(f&#39;Minimum latency: {min_latency} ms&#39;)</p><p/><p># Calculate the average latency avg_latency = df[&#39;latency&#39;].mean() print(f&#39;Average latency: {avg_latency} ms&#39;) # Calculate the maximum latency max_latency = df[&#39;latency&#39;].max()</p><p>print(f&#39;Maximum latency: {max_latency} ms&#39;) # Calculate the minimum latency</p><p>min_latency = df[&#39;latency&#39;].min()</p><p>print(f&#39;Minimum latency: {min_latency} ms&#39;)</p><p><br/></p><p><a>Visualize the Data</a></p><p>We can use the Matplotlib library to create a plot of the latency data, which can help us identify any trends or patterns.</p><p><br/></p><p>import matplotlib.pyplot as plt</p><p># Create a plot of the latency data plt.figure(figsize=(10, 6))</p><p>plt.plot(df.index, df[&#39;latency&#39;], label=&#39;Latency&#39;) plt.xlabel(&#39;Time&#39;)</p><p>plt.ylabel(&#39;Latency (ms)&#39;) plt.title(&#39;Network Latency Over Time&#39;) plt.legend()</p><p>plt.grid(True)</p><p>plt.show()</p><p>import matplotlib.pyplot as plt</p><p># Create a plot of the latency data plt.figure(figsize=(10, 6))</p><p>plt.plot(df.index, df[&#39;latency&#39;], label=&#39;Latency&#39;) plt.xlabel(&#39;Time&#39;)</p><p>plt.ylabel(&#39;Latency (ms)&#39;) plt.title(&#39;Network Latency Over Time&#39;) plt.legend()</p><p>plt.grid(True)</p><p>plt.show()</p><p/><p>import matplotlib.pyplot as plt</p><p># Create a plot of the latency data plt.figure(figsize=(10, 6))</p><p>plt.plot(df.index, df[&#39;latency&#39;], label=&#39;Latency&#39;) plt.xlabel(&#39;Time&#39;)</p><p>plt.ylabel(&#39;Latency (ms)&#39;) plt.title(&#39;Network Latency Over Time&#39;) plt.legend()</p><p>plt.grid(True)</p><p>plt.show()</p><p>This script will create a line plot of the network latency over time, which can help you visualize how the latency is changing and identify any trends or issues.</p><h2><a>Summary</a></h2><p>In Chapter 5, we embarked on the journey of network monitoring and analysis, a crucial aspect of network management that helps identify potential issues and maintain the overall health of the network. Starting with Simple Network Management Protocol (SNMP), we understood its significance in the management of networked devices. We explored the Python library PySNMP, which simplifies SNMP operations, allowing us to retrieve and manipulate data from SNMP- enabled devices. From basic to modern usage, we practiced SNMP operations, discovering the versatility of this protocol.</p><p>Subsequently, we dived into the world of network traffic monitoring, learning about its various indicators like bandwidth usage, packet loss, latency, jitter, and throughput. We harnessed the power of Python libraries like psutil and scapy to create scripts that capture live network traffic data and analyze it, learning how to measure these indicators practically. We discussed how to calculate the bandwidth usage, demonstrated how to measure packet loss, and saw how to evaluate latency, jitter, and throughput. This part of the chapter provided a comprehensive understanding of network traffic monitoring and performance analysis.</p><p>Finally, we explored the analysis of network performance, where we utilized Python&#39;s data analysis libraries like pandas and Matplotlib. We discussed how to load network data, conduct basic analysis, and visualize the results. This analysis can identify trends and anomalies that might indicate network issues. Thus, in this chapter, we learned how Python aids in automating and simplifying network monitoring and analysis, demonstrating its vast capabilities in the realm of network management.</p><p><br/></p><p></p><p></p><p><a href="part5.htm">&lt; Назад</a> | <a href="index.html">Содержимое</a> | <a href="part7.htm">Далее &gt;</a></p><p></p></body></html>
