<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta/><title>Chapter 2: TCP, UDP and Socket Programming</title><link href="navigation.css"/><link href="document.css"/></head><body><p><a href="part2.htm">&lt; Назад</a> | <a href="index.html">Содержимое</a> | <a href="part4.htm">Далее &gt;</a></p><p><a>CHAPTER 2: TCP, UDP AND SOCKET PROGRAMMING</a><a>&zwnj;</a></p><p>In this chapter, we will delve deeper into network protocols and layers, exploring their concepts and learning how to implement them using Python&#39;s socket programming. We will discuss some essential network protocols in detail, understand the layers at which they operate, and practice writing simple Python scripts to work with these protocols.</p><p>This chapter and various topics covered in it will provide a comprehensive understanding of network protocols and layers, along with hands-on experience in implementing them using Python&#39;s socket programming. This knowledge will enable you to develop more complex networking applications and further hone your skills as a network administrator. Let us explore and learn!</p><h2><a>Transport Layer Protocols: TCP and UDP</a></h2><p>The transport layer, also known as Layer 4 in the OSI model, is responsible for providing end-to- end communication services between applications running on different devices within a network. It ensures reliable and efficient data transfer by implementing various error detection, flow control, and congestion control mechanisms. The two primary transport layer protocols are the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP). In this section, we will discuss both protocols in detail, highlighting their key features, similarities, and differences.</p><p><a>Transmission Control Protocol (TCP)</a></p><p>TCP is a connection-oriented, reliable, and full-duplex transport layer protocol. It ensures that data is delivered accurately and in the correct order, making it suitable for applications that require high reliability, such as web browsing, file transfers, and email.</p><p>Key Features of TCP</p><p>●   Connection-Oriented: TCP establishes a connection between the sender and receiver before transmitting data. This connection is maintained throughout the communication process until both parties have finished exchanging data.</p><p>●    Reliable: TCP uses error detection mechanisms, such as checksums and sequence numbers, to ensure that data is transmitted accurately and in the correct order. If a packet is lost or corrupted during transmission, the recipient can request retransmission.</p><p>●  Flow Control: TCP manages the rate of data transmission between sender and receiver to prevent overloading the recipient&#39;s buffer. This is achieved using a sliding window mechanism, which allows the sender to transmit data only when the receiver has available buffer space.</p><p>●  Congestion Control: TCP monitors network congestion and adjusts the transmission rate accordingly, preventing packet loss and ensuring efficient use of network resources. This is achieved through mechanisms like slow start, congestion avoidance, fast retransmit, and fast recovery.</p><p>●   Full-Duplex: TCP supports simultaneous data transmission in both directions, allowing the sender and receiver to exchange data concurrently.</p><p><a>User Datagram Protocol (UDP)</a></p><p>UDP is a connectionless, unreliable, and lightweight transport layer protocol. It does not guarantee the delivery, order, or integrity of data, making it suitable for applications that prioritize speed and simplicity over reliability, such as streaming media, online gaming, and Voice over IP (VoIP).</p><p>Key Features of UDP:</p><p>●   Connectionless: Unlike TCP, UDP does not establish a connection before transmitting</p><p>data. Instead, it sends datagrams independently, without maintaining a connection between sender and receiver.</p><p>●   Unreliable: UDP does not provide error detection, flow control, or congestion control mechanisms. As a result, it cannot guarantee the delivery, order, or integrity of data. However, this simplicity allows for faster data transmission and lower overhead.</p><p>●  Lightweight: UDP has a smaller header size compared to TCP, resulting in less overhead and faster processing. This makes it an ideal choice for applications that require minimal latency.</p><p>●   No Flow Control or Congestion Control: As UDP does not implement flow control or congestion control mechanisms, it can send data as quickly as the sender generates it. This is beneficial for real-time applications, such as video streaming or online gaming, where occasional packet loss is acceptable.</p><p><a>Comparing TCP and UDP</a></p><p>Reliability: TCP is a reliable protocol that guarantees data delivery, order, and integrity. In contrast, UDP is an unreliable protocol that does not provide any such guarantees.</p><p>Connection: TCP is connection-oriented, establishing a connection before data transmission. UDP is connectionless, sending data without prior connection establishment.</p><p>Flow Control and Congestion Control: TCP implements flow control and congestion control mechanisms, ensuring efficient use of network resources and preventing buffer overflows. UDP does not provide any such features.</p><p>Speed and Overhead: TCP has higher overhead due to its error detection, flow control, and congestion control mechanisms, resulting in slower data transmission. UDP has lower overhead and faster transmission, making it suitable for applications that prioritize speed and minimal latency.</p><p>Use Cases: TCP is ideal for applications that require high reliability, such as web browsing, file transfers, and email. UDP is suitable for applications that can tolerate occasional packet loss and prioritize speed, such as streaming media, online gaming, and VoIP.</p><p>In summary, both TCP and UDP serve different purposes and are suitable for different types of applications. TCP is the go-to protocol when reliability, data integrity, and order are crucial, while UDP is preferred for applications that prioritize speed and low latency. It is essential for network administrators to understand the differences between these two transport layer protocols to make informed decisions when configuring and troubleshooting networks.</p><h2><a>Socket Programming in Python</a></h2><p>Sockets are the fundamental building blocks of network communication and play a crucial role in establishing connections between devices. They provide an interface for applications to send and receive data over networks. Understanding the basics and types of sockets is essential before diving into socket programming in Python.</p><p><a>Basics of Sockets</a></p><p>A socket is an endpoint in a network communication process that enables data exchange between two devices. It is associated with a unique combination of an IP address and a port number, which together identify a specific process running on a device. Sockets enable applications to send and receive data using transport layer protocols like TCP and UDP.</p><p>There are two primary operations performed by sockets: listening and connecting. A server socket listens for incoming connections from client sockets, while client sockets initiate connections to server sockets. Once a connection is established, data can be transmitted bidirectionally between the server and client.</p><p>Sockets can be broadly classified into two categories based on the transport layer protocol they use: stream sockets and datagram sockets.</p><p><a>Stream Sockets (TCP Sockets)</a></p><p>Stream sockets use the Transmission Control Protocol (TCP) for communication. They are connection-oriented, meaning that a connection is established between the sender and receiver before data transmission. Stream sockets ensure reliable, in-order, and error-free communication, making them suitable for applications that require high reliability, such as web browsing, file transfers, and email.</p><p>Some key characteristics of stream sockets are:</p><p>●  Reliable: They guarantee accurate, in-order, and error-free data transmission.</p><p>●  Connection-oriented: A connection must be established before data can be exchanged.</p><p>●  Full-duplex: They allow simultaneous data transmission in both directions.</p><p>●  Suitable for applications requiring high reliability and accurate data transmission.</p><p><a>Datagram Sockets (UDP Sockets)</a></p><p>Datagram sockets use the User Datagram Protocol (UDP) for communication. They are connectionless, meaning that data is transmitted independently without establishing a connection between sender and receiver. Datagram sockets are suitable for applications that prioritize speed and simplicity over reliability, such as streaming media, online gaming, and Voice over IP (VoIP).</p><p>Some key characteristics of datagram sockets are:</p><p>●  Unreliable: They do not guarantee data delivery, order, or integrity.</p><p>●  Connectionless: No connection is established before data transmission.</p><p>●   Lightweight: They have a smaller header size compared to stream sockets, resulting in</p><p>lower overhead and faster processing.</p><p>●  Suitable for applications requiring minimal latency and fast data transmission.</p><p>Understanding the basics and types of sockets is essential for successful socket programming in Python. Stream sockets (TCP) and datagram sockets (UDP) cater to different types of applications based on their reliability, connection orientation, and latency requirements. By choosing the appropriate socket type, you can develop efficient network applications that meet the specific needs of various use cases.</p><h2><a>Python Socket Library</a></h2><p>Python provides a built-in library called &#39;socket&#39; that makes it easy to perform network programming tasks, such as creating, connecting, and managing sockets. The socket library provides various functions and classes for working with both TCP (stream) and UDP (datagram) sockets. In this section, we will learn about the socket library and how to use it for socket programming in Python.</p><p><a>Importing Socket Library</a></p><p>To start using the socket library, you need to import it at the beginning of your Python script:</p><p><br/></p><p>import                         socket                          </p><p><a>Creating a Socket in Python</a></p><p>To create a socket in Python, you can use the socket.socket() function provided by the socket library. This function takes two arguments: the address family (AF) and the socket type (SOCK). The address family is used to specify the protocol family (IPv4 or IPv6), and the socket type is used to specify the transport layer protocol (TCP or UDP).</p><p>For example, to create a TCP socket using IPv4, you would call the socket.socket() function like this:</p><p><br/></p><p>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p/><p>tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>Similarly, to create a UDP socket using IPv4, you would use the following code:</p><p><br/></p><p>udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p>udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p/><p>udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p><br/></p><p><a>Binding Socket to IP Address and Port</a></p><p>Before a server socket can listen for incoming connections, it must be bound to an IP address and port number. This can be done using the bind() method of the socket object. The bind() method takes a single argument, a tuple containing the IP address and port number.</p><p>For example, to bind a socket to the IP address &#39;127.0.0.1&#39; and port number 12345, you would use the following code:</p><p><br/></p><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>tcp_socket.bind(address)</p><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>tcp_socket.bind(address)</p><p/><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>tcp_socket.bind(address)</p><p><br/></p><p><a>Closing a Socket</a></p><p>When you are done using a socket, it is important to close it using the close() method. This frees up system resources and prevents potential conflicts with other applications.</p><p><br/></p><p>tcp_socket.close()                        </p><p>Now that you have a basic understanding of the socket library and how to create, bind, and close sockets in Python, you are ready to explore more advanced topics, such as establishing connections, sending and receiving data, and implementing server and client applications using TCP and UDP sockets.</p><h2><a>TCP Socket Programming</a></h2><p>Now, let us learn and practice to establish TCP connections, send and receive data over TCP, and terminate a TCP connection using Python&#39;s socket library.</p><p><a>Establishing a TCP Connection</a></p><p>To establish a TCP connection, the server must first create a socket, bind it to an IP address and port, and then start listening for incoming client connections. The following steps demonstrate how to achieve this:</p><p>Create a socket:</p><p><br/></p><p>import socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>import socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p/><p>import socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>Bind the socket to an IP address and port:</p><p><br/></p><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p/><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p>Listen for incoming connections:</p><p><br/></p><p>server_socket.listen(5) # The argument (5) is the maximum number of queued connections.</p><p>server_socket.listen(5) # The argument (5) is the maximum number of queued connections.</p><p/><p>server_socket.listen(5) # The argument (5) is the maximum number of queued connections.</p><p>Accept an incoming connection:</p><p><br/></p><p>client_socket, client_address = server_socket.accept()</p><p>print(f&quot;Connection established with {client_address}&quot;)</p><p>client_socket, client_address = server_socket.accept()</p><p>print(f&quot;Connection established with {client_address}&quot;)</p><p/><p>client_socket, client_address = server_socket.accept()</p><p>print(f&quot;Connection established with {client_address}&quot;)</p><p>On the client-side, you need to create a socket and connect to the server&#39;s IP address and port.</p><p>Create a socket:</p><p><br/></p><p>import socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>import socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p/><p>import socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p>Connect to the server:</p><p><br/></p><p>server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.connect(server_address)</p><p>server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.connect(server_address)</p><p/><p>server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.connect(server_address)</p><p><br/></p><p><a>Sending and Receiving Data over TCP</a></p><p>Once a connection is established, you can use the send() and recv() methods to transmit and receive data over TCP.</p><p>Sending Data:</p><p>To send data, you can use the send() method of the socket object. This method takes a single argument, the data to be sent, which must be a bytes-like object.</p><p>Example (Client-Side):</p><p><br/></p><p>data = &quot;Hello, Server!&quot;</p><p>client_socket.send(data.encode()) # Convert the string to bytes and send it.</p><p>data = &quot;Hello, Server!&quot;</p><p>client_socket.send(data.encode()) # Convert the string to bytes and send it.</p><p/><p>data = &quot;Hello, Server!&quot;</p><p>client_socket.send(data.encode()) # Convert the string to bytes and send it.</p><p>Receiving Data:</p><p>To receive data, you can use the recv() method of the socket object. This method takes a single argument, the maximum amount of data (in bytes) to receive, and returns the received data as a bytes-like object.</p><p>Example (Server-Side):</p><p><br/></p><p>data = server_socket.recv(1024) # Receive up to 1024 bytes of data.</p><p>print(f&quot;Received data: {data.decode()}&quot;) # Convert the bytes to a string and print it.</p><p>data = server_socket.recv(1024) # Receive up to 1024 bytes of data.</p><p>print(f&quot;Received data: {data.decode()}&quot;) # Convert the bytes to a string and print it.</p><p/><p>data = server_socket.recv(1024) # Receive up to 1024 bytes of data.</p><p>print(f&quot;Received data: {data.decode()}&quot;) # Convert the bytes to a string and print it.</p><p><br/></p><p><a>Terminating a TCP Connection</a></p><p>To close a TCP connection, both the server and client should close their respective sockets using the close() method.</p><p>Server-Side:</p><p><br/></p><p>client_socket.close()</p><p>server_socket.close()</p><p>client_socket.close()</p><p>server_socket.close()</p><p/><p>client_socket.close()</p><p>server_socket.close()</p><p>Client-Side:</p><p>client_socket.close()                       </p><p>In the simplest terms, to execute TCP socket programming in Python, you will first need to build and bind a socket, then establish a connection, then send and receive data, and lastly close the connection.</p><h2><a>Implementing a TCP Server and Client</a></h2><p>Considering so far what we learned, we can start with creating a simple TCP server and client using Python&#39;s socket library. The server will listen for incoming client connections, receive a message from the client, print the received message, and send a response back to the client.</p><p><a>TCP Server</a></p><p>Create a file named &quot;tcp_server.py&quot; and add the following code:</p><p><br/></p><p>import socket</p><p># Create a socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p># Bind the socket to an IP address and port address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p># Listen for incoming connections server_socket.listen(5) print(&quot;Server listening on&quot;, address) while True:</p><p># Accept an incoming connection</p><p>client_socket, client_address = server_socket.accept() print(f&quot;Connection established with {client_address}&quot;) # Receive data from the client</p><p>data = client_socket.recv(1024) print(f&quot;Received data: {data.decode()}&quot;) # Send a response back to the client response = &quot;Hello, Client!&quot; client_socket.send(response.encode())</p><p>import socket</p><p># Create a socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p># Bind the socket to an IP address and port address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p># Listen for incoming connections server_socket.listen(5) print(&quot;Server listening on&quot;, address) while True:</p><p># Accept an incoming connection</p><p>client_socket, client_address = server_socket.accept() print(f&quot;Connection established with {client_address}&quot;) # Receive data from the client</p><p>data = client_socket.recv(1024) print(f&quot;Received data: {data.decode()}&quot;) # Send a response back to the client response = &quot;Hello, Client!&quot; client_socket.send(response.encode())</p><p/><p>import socket</p><p># Create a socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p># Bind the socket to an IP address and port address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p># Listen for incoming connections server_socket.listen(5) print(&quot;Server listening on&quot;, address) while True:</p><p># Accept an incoming connection</p><p>client_socket, client_address = server_socket.accept() print(f&quot;Connection established with {client_address}&quot;) # Receive data from the client</p><p>data = client_socket.recv(1024) print(f&quot;Received data: {data.decode()}&quot;) # Send a response back to the client response = &quot;Hello, Client!&quot; client_socket.send(response.encode())</p><p># Close the client socket client_socket.close()</p><p># Close the server socket (unreachable in this particular sample program)</p><p>server_socket.close()</p><p># Close the client socket client_socket.close()</p><p># Close the server socket (unreachable in this particular sample program)</p><p>server_socket.close()</p><p/><p># Close the client socket client_socket.close()</p><p># Close the server socket (unreachable in this particular sample program)</p><p>server_socket.close()</p><p><br/></p><p><a>TCP Client</a></p><p>Create a file named &quot;tcp_client.py&quot; and add the following code:</p><p><br/></p><p>import socket</p><p># Create a socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p># Connect to the server server_address = (&#39;127.0.0.1&#39;, 12345) client_socket.connect(server_address)</p><p>print(f&quot;Connected to server at {server_address}&quot;) # Send data to the server</p><p>data = &quot;Hello, Server!&quot; client_socket.send(data.encode()) # Receive data from the server</p><p>response = client_socket.recv(1024) print(f&quot;Received data: {response.decode()}&quot;) # Close the client socket</p><p>client_socket.close()</p><p>import socket</p><p># Create a socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p># Connect to the server server_address = (&#39;127.0.0.1&#39;, 12345) client_socket.connect(server_address)</p><p>print(f&quot;Connected to server at {server_address}&quot;) # Send data to the server</p><p>data = &quot;Hello, Server!&quot; client_socket.send(data.encode()) # Receive data from the server</p><p>response = client_socket.recv(1024) print(f&quot;Received data: {response.decode()}&quot;) # Close the client socket</p><p>client_socket.close()</p><p/><p>import socket</p><p># Create a socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p><p># Connect to the server server_address = (&#39;127.0.0.1&#39;, 12345) client_socket.connect(server_address)</p><p>print(f&quot;Connected to server at {server_address}&quot;) # Send data to the server</p><p>data = &quot;Hello, Server!&quot; client_socket.send(data.encode()) # Receive data from the server</p><p>response = client_socket.recv(1024) print(f&quot;Received data: {response.decode()}&quot;) # Close the client socket</p><p>client_socket.close()</p><p><br/></p><p><a>Running the TCP Server and Client</a></p><p>To run the TCP server and client, follow these steps:</p><p>Open two terminal windows.</p><p>In the first terminal, navigate to the directory containing &quot;tcp_server.py&quot; and run the following command:</p><p><br/></p><p>python                      tcp_server.py                       </p><p>The server will start listening for incoming connections.</p><p>In the second terminal, navigate to the directory containing &quot;tcp_client.py&quot; and run the following command:</p><p><br/></p><p>python tcp_client.py</p><p>python tcp_client.py</p><p/><p>python tcp_client.py</p><p>The client will connect to the server, send a message, receive a response, and print the received data.</p><p>Observe the output in both terminals. The server should display the connection details and the received message, while the client should display the connection details and the received response.</p><p>Creating a TCP server and client in Python requires establishing connections, binding sockets, transmitting and receiving data, and finally closing the connections. Additionally, you will need to create sockets and bind them. If you follow these instructions, you will be able to construct a wide variety of server and client applications that take advantage of the connection-oriented and reliable characteristics offered by the TCP protocol.</p><h2><a>UDP Socket Programming in Python</a></h2><p>Similar to TCP socket programming, we will also learn about UDP socket programming in Python, including establishing a UDP connection, working with connectionless sockets, and sending and receiving data over UDP. We will use a similar example as used in the previous section, with a server that listens for incoming messages and sends a response back to the client.</p><p><a>Establishing a UDP Connection</a></p><p>Unlike TCP, UDP is a connectionless protocol, meaning there is no need to establish a connection between the server and client. Instead, the server and client simply send and receive data without establishing a formal connection.</p><p><a>Working with Connectionless Sockets</a></p><p>To create a UDP server, you need to create a socket, bind it to an IP address and port, and start listening for incoming datagrams. The following steps demonstrate how to achieve this:</p><p>Create a socket:</p><p><br/></p><p>import socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p>import socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p/><p>import socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p>Bind the socket to an IP address and port:</p><p><br/></p><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p/><p>address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address)</p><p><br/></p><p>On the client-side, you need to create a socket, and you can directly send and receive data without connecting to the server.</p><p>Create a socket:</p><p><br/></p><p>import socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p>import socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p/><p>import socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p><br/></p><p><a>Sending and Receiving Data over UDP</a></p><p>Sending Data:</p><p>To send data over UDP, you can use the sendto() method of the socket object. This method takes two arguments: the data to be sent (a bytes-like object) and the destination address (a tuple</p><p>containing the IP address and port number). Example (Client-Side):</p><p>data = &quot;Hello, Server!&quot; server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.sendto(data.encode(), server_address)</p><p>data = &quot;Hello, Server!&quot; server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.sendto(data.encode(), server_address)</p><p/><p>data = &quot;Hello, Server!&quot; server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.sendto(data.encode(), server_address)</p><p>Receiving Data:</p><p>To receive data over UDP, you can use the recvfrom() method of the socket object. This method takes a single argument, the maximum amount of data (in bytes) to receive, and returns the received data as a bytes-like object and the source address.</p><p>Example (Server-Side):</p><p><br/></p><p>data, client_address = server_socket.recvfrom(1024)</p><p>print(f&quot;Received data: {data.decode()} from {client_address}&quot;)</p><p>data, client_address = server_socket.recvfrom(1024)</p><p>print(f&quot;Received data: {data.decode()} from {client_address}&quot;)</p><p/><p>data, client_address = server_socket.recvfrom(1024)</p><p>print(f&quot;Received data: {data.decode()} from {client_address}&quot;)</p><h2><a>Implementing a UDP Server and Client</a></h2><p><a>UDP Server</a></p><p>Create a file named &quot;udp_server.py&quot; and add the following code:</p><p><br/></p><p>import socket</p><p># Create a socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p># Bind the socket to an IP address and port address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address) print(&quot;Server listening on&quot;, address) while True:</p><p># Receive data from the client</p><p>data, client_address = server_socket.recvfrom(1024) print(f&quot;Received data: {data.decode()} from {client_address}&quot;) # Send a response back to the client</p><p>response = &quot;Hello, Client!&quot;</p><p>server_socket.sendto(response.encode(), client_address)</p><p>import socket</p><p># Create a socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p># Bind the socket to an IP address and port address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address) print(&quot;Server listening on&quot;, address) while True:</p><p># Receive data from the client</p><p>data, client_address = server_socket.recvfrom(1024) print(f&quot;Received data: {data.decode()} from {client_address}&quot;) # Send a response back to the client</p><p>response = &quot;Hello, Client!&quot;</p><p>server_socket.sendto(response.encode(), client_address)</p><p/><p>import socket</p><p># Create a socket</p><p>server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</p><p># Bind the socket to an IP address and port address = (&#39;127.0.0.1&#39;, 12345)</p><p>server_socket.bind(address) print(&quot;Server listening on&quot;, address) while True:</p><p># Receive data from the client</p><p>data, client_address = server_socket.recvfrom(1024) print(f&quot;Received data: {data.decode()} from {client_address}&quot;) # Send a response back to the client</p><p>response = &quot;Hello, Client!&quot;</p><p>server_socket.sendto(response.encode(), client_address)</p><p><br/></p><p><a>UDP Client</a></p><p>Create a file named &quot;udp_client.py&quot; and add the following code:</p><p><br/></p><p>import socket</p><p># Create a socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # Send data to the server</p><p>import socket</p><p># Create a socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # Send data to the server</p><p/><p>import socket</p><p># Create a socket</p><p>client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # Send data to the server</p><p>data = &quot;Hello, Server!&quot; server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.sendto(data.encode(), server_address) # Receive data from the server</p><p>response, server_address = client_socket.recvfrom(1024) print(f&quot;Received data: {response.decode()} from {server_address}&quot;)</p><p>Close the client socket</p><p>client_socket.close()</p><p>data = &quot;Hello, Server!&quot; server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.sendto(data.encode(), server_address) # Receive data from the server</p><p>response, server_address = client_socket.recvfrom(1024) print(f&quot;Received data: {response.decode()} from {server_address}&quot;)</p><p>Close the client socket</p><p>client_socket.close()</p><p/><p>data = &quot;Hello, Server!&quot; server_address = (&#39;127.0.0.1&#39;, 12345)</p><p>client_socket.sendto(data.encode(), server_address) # Receive data from the server</p><p>response, server_address = client_socket.recvfrom(1024) print(f&quot;Received data: {response.decode()} from {server_address}&quot;)</p><p>Close the client socket</p><p>client_socket.close()</p><p><br/></p><p><a>Running the UDP Server and Client</a></p><p>To run the UDP server and client, follow these steps:</p><p>Open two terminal windows.</p><p>In the first terminal, navigate to the directory containing &quot;udp_server.py&quot; and run the following command:</p><p><br/></p><p>python                      udp_server.py                      </p><p>The server will start listening for incoming datagrams.</p><p>In the second terminal, navigate to the directory containing &quot;udp_client.py&quot; and run the following command:</p><p>python                      udp_client.py                       </p><p>The client will send a message to the server and receive a response, printing the received data.</p><p>Observe the output in both terminals. The server should display the received message and the client&#39;s address, while the client should display the received response and the server&#39;s address.</p><p>Writing a UDP socket in Python is far less complicated than writing a TCP socket in Python due to the fact that there is no need to create a connection between the server and the client. You can construct server and client programs that take use of the speed and simplicity offered by the UDP protocol by employing connectionless sockets to communicate with one another via the methods&#39;sendto()&#39; and&#39;recvfrom()&#39;.</p><h2><a>Summary</a></h2><p>Understanding network protocols and layers, as well as socket programming in Python, were the primary focuses of this chapter. We started off by conducting some conceptual research on network protocols and the significance of these protocols in terms of their role in facilitating communication between devices on a network. Following that, we dove deeper into the specifics of transport layer protocols, specifically TCP and UDP, due to the significant impact that they have on networking.</p><p>Transmission Control Protocol, also known simply as TCP, is a connection-oriented protocol that ensures the delivery of data in an ordered and reliable fashion. We learned about the process of closing a connection, the three-way handshake that is required to establish a connection, the flow control and congestion control mechanisms that ensure data integrity, and the process of establishing a connection in the first place.</p><p>User Datagram Protocol, also known as UDP, is a connectionless and lightweight protocol that offers more rapid data transmission at the expense of reliability. We went over the key differences between TCP and UDP, as well as how each protocol is best suited for specific kinds of applications.</p><p>Following that, we moved on to the Python socket programming, which gives us the ability to create network applications by utilizing the built-in socket library. We began by gaining an understanding of the fundamentals of sockets, which included the different types of sockets (TCP and UDP), as well as the procedure for creating, binding, and listening for connections. Through the study of TCP socket programming, we became familiar with the processes of establishing connections, sending and receiving data over TCP, and closing a TCP connection. For the purpose of demonstrating these concepts, we built a straightforward TCP server and client. Following that, we went on to study how to program using UDP sockets, which entails working with connectionless sockets and transmitting and receiving data using UDP. We went over the fundamental steps involved in creating and binding sockets, as well as sending data with the sendto() method and receiving data with the recvfrom() method. In order to better illustrate the concepts, we also implemented a straightforward UDP server and client. In a nutshell, this chapter laid a solid groundwork for future study in Python&#39;s socket programming and provided an overview of network protocols and layers.</p><p><br/></p><p></p><p></p><p><a href="part2.htm">&lt; Назад</a> | <a href="index.html">Содержимое</a> | <a href="part4.htm">Далее &gt;</a></p><p></p></body></html>
