<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta/><title>Chapter 11: Ansible and Python</title><link href="navigation.css"/><link href="document.css"/></head><body><p><a href="part11.htm">&lt; Назад</a> | <a href="index.html">Содержимое</a></p><p><a>CHAPTER 11: ANSIBLE AND PYTHON</a><a>&zwnj;</a></p><h2><a>Introduction to Ansible</a></h2><p>Ansible is an open-source automation tool that provides a powerful, flexible framework for managing and configuring systems. It uses a declarative language to describe system configuration, allowing administrators to define what they want the system to look like, rather than specifying the steps to get there. This makes it easier to manage complex systems and reduces the likelihood of errors due to manual configuration changes.</p><p>In the context of network automation, Ansible allows you to manage the configurations of network devices, automate repetitive tasks, and coordinate complex sets of actions across multiple devices. By defining your network configuration in Ansible, you can ensure consistency across all devices, reduce the time needed for configuration updates, and minimize the potential for manual errors. Ansible uses a simple, human-readable data serialization language called YAML to define automation jobs, which it calls &#39;playbooks&#39;. These playbooks can be used to automate tasks such as software installations, service configurations, and updates. Ansible works by connecting to your nodes (the systems you&#39;re managing) and pushing out small programs, called &#39;Ansible modules&#39;, to them. These programs are written in Python, which makes Ansible especially relevant in the context of network automation with Python. Once these programs are executed on the nodes, they communicate back with the Ansible machine, remove themselves from the nodes, and provide information back to Ansible about what happened.</p><p>Python is the backend of Ansible, meaning that Ansible&#39;s modules, which are used to interact with system resources like services, packages, or files, are written in Python. This means that, if you&#39;re already working with Python for network automation, learning Ansible can leverage your existing skills and knowledge. Another significant advantage of Ansible is that it&#39;s agentless. Unlike other configuration management tools, it doesn&#39;t require you to install any software on the nodes it manages. It communicates over standard SSH (or WinRM for Windows nodes), which makes it easy to set up and reduces the potential for conflicts with other software. Ansible is also highly flexible and can be used in combination with other tools for more complex automation tasks. For instance, you can use Ansible to orchestrate more complex automation workflows, integrate with CI/CD pipelines, or manage multi-tier applications.</p><h2><a>Setting up Ansible on Windows</a></h2><p>Installing Ansible on Windows is a little tricky because Ansible does not run directly on Windows. However, you can run Ansible within a Windows Subsystem for Linux (WSL) environment, or you can run Ansible in a Docker container, or in a virtual machine running Linux. Following are the steps to install Ansible on Windows using WSL:</p><p><a>Install Windows Subsystem for Linux (WSL)</a></p><p>Open PowerShell as Administrator and run:</p><p><br/></p><p>wsl --install</p><p>wsl --install</p><p/><p>wsl --install</p><p>This command will install WSL with the default Linux distribution (Ubuntu). If you want to use another distribution, you can select it from the Microsoft Store after installing WSL.</p><p><a>Update and Upgrade WSL:</a></p><p>Launch your WSL Linux distribution (e.g., Ubuntu) from the Start menu. Update your package lists:</p><p>sudo apt-get update</p><p>sudo apt-get update</p><p/><p>sudo apt-get update</p><p>Upgrade your installed packages:</p><p><br/></p><p>sudo           apt-get           upgrade                       </p><p><a>Install Ansible</a></p><p>Still within WSL, install the software-properties-common package (this provides the add-apt- repository command):</p><p><br/></p><p>sudo    apt-get    install    software-properties-common           </p><p>Add the Ansible PPA:</p><p><br/></p><p>sudo apt-add-repository --yes --update ppa:ansible/ansible</p><p>sudo apt-add-repository --yes --update ppa:ansible/ansible</p><p/><p>sudo apt-add-repository --yes --update ppa:ansible/ansible</p><p><br/></p><p>sudo apt-get install ansible</p><p>sudo apt-get install ansible</p><p/><p>sudo apt-get install ansible</p><p>Verify Installation:</p><p>You can verify the installation by running:</p><p>ansible                        --version                         </p><p>This should print the installed Ansible version.</p><p>It&#39;s a good practice to create a virtual environment for your Python projects. You can install the venv module if it&#39;s not already installed:</p><p><br/></p><p>sudo      apt-get      install      python3-venv                  </p><p>Navigate to your project directory and create a new virtual environment:</p><p><br/></p><p>python3        -m        venv        env                       </p><p>Activate the virtual environment:</p><p><br/></p><p>source env/bin/activate</p><p>source env/bin/activate</p><p/><p>source env/bin/activate</p><p>Now, you can install any Python packages you need for your project using pip, and they will be installed into the virtual environment. The above steps should guide you to have a working Ansible installation within a Python virtual environment on Windows. You can use Ansible to define and run your network automation tasks, and use Python to write custom Ansible modules if needed.</p><h2><a>Ansible Modules, Tasks and Playbooks</a></h2><p>In Ansible, modules, tasks, and playbooks are the key components to define and orchestrate automation.</p><p><a>Modules</a></p><p>In the context of Ansible, a module is a standalone script that can be used by the Ansible API or by the ansible or ansible-playbook CLI command. Modules are like the tools in Ansible&#39;s toolbox. They perform specific functions and are designed to be idempotent, which means they can be run multiple times without causing redundant changes.</p><p>For example, there&#39;s a module called ping that just checks if you can connect to your targets. There&#39;s a command module that can execute arbitrary commands. There are also a lot of specialized modules for different systems, like apt or yum for package management, file for managing files, copy for copying files, and many more.</p><p><a>Tasks</a></p><p>A task is nothing but a call to an Ansible module. It represents a single step in your automation process. You can think of a task as an application of a module. Tasks are defined within a playbook and have a name and a module. They may also have some additional parameters depending on the module. For example, if you&#39;re using the command module, the command you want to run would be one of the parameters.</p><p><a>Playbooks</a></p><p>Playbooks are at the heart of Ansible&#39;s operation, and they&#39;re where tasks are defined. They are written in YAML format and describe the desired state of something, not the steps to get there. A playbook contains one or more &quot;plays&quot;. Each play is a mapping between a set of hosts (known as the inventory) and a set of tasks. When a playbook is run, Ansible executes each play in order, and for each play, it runs each task in order on every host the play applies to.</p><p>In a playbook, you might have a play that targets your web servers and another play that targets your database servers. Within each play, you would have tasks that use modules to install necessary packages, configure settings, start services, etc.</p><p>An example of a simple playbook might look like this:</p><p><br/></p><p>- name: install and start apache hosts: webservers</p><p>tasks:</p><p>- name: install apache</p><p>- name: install and start apache hosts: webservers</p><p>tasks:</p><p>- name: install apache</p><p/><p>- name: install and start apache hosts: webservers</p><p>tasks:</p><p>- name: install apache</p><p>yum:</p><p>name: httpd state: present</p><p>- name: start apache service:</p><p>name: httpd</p><p>state: started</p><p>yum:</p><p>name: httpd state: present</p><p>- name: start apache service:</p><p>name: httpd</p><p>state: started</p><p/><p>yum:</p><p>name: httpd state: present</p><p>- name: start apache service:</p><p>name: httpd</p><p>state: started</p><p>In this playbook, there&#39;s a single play that targets hosts in the webservers group. The play has two tasks: one uses the yum module to install the httpd package, and the other uses the service module to start the httpd service.</p><p><a>Inventory</a></p><p>Another important concept in Ansible is the inventory. This is a list of nodes that Ansible will manage. Nodes are typically servers, but they can also be things like network devices, or even cloud resources. The inventory is defined in a file (by default, this file is called hosts and is located in /etc/ansible).</p><p>You can specify nodes using their hostname or IP address, and you can also group nodes together. For example:</p><p><br/></p><p>[webservers] web1.example.com web2.example.com [dbservers]</p><p>db1.example.com</p><p>[webservers] web1.example.com web2.example.com [dbservers]</p><p>db1.example.com</p><p/><p>[webservers] web1.example.com web2.example.com [dbservers]</p><p>db1.example.com</p><p>In this inventory file, there are two groups of nodes: webservers and dbservers. You can target groups in your playbooks.</p><p><a>Variables and Facts</a></p><p>Ansible allows you to use variables to deal with differences between systems. For example, you might have a variable for the version of a package you want to install, or for the name of a service you want to start. Ansible also gathers information about the nodes it manages in variables called facts. Facts are things like the node&#39;s IP addresses, its operating system, and so</p><p>on. You can use facts in your playbooks to make decisions or change the behavior of tasks.</p><p><a>Roles</a></p><p>Roles in Ansible provide a framework for fully independent, or interdependent collections of variables, tasks, files, templates, and modules. In other words, roles are a way to group related tasks together and make them reusable. This allows you to share your automation and collaborate with others.</p><p>For example, you might have a role for setting up a web server. This role would include tasks for installing the necessary packages, writing the configuration file, and starting the service.</p><p>To tie it all together, below is what a simple Ansible setup might look like:</p><p>●    An inventory file that lists all your nodes and groups them into webservers and dbservers.</p><p>●   A playbook that uses the yum and service modules to install and start Apache. The playbook targets the webservers group in the inventory.</p><p>●  A variable for the name of the package to install (httpd).</p><p>●  To run this playbook, you would use the ansible-playbook command:</p><p><br/></p><p>ansible-playbook     -i     inventory     playbook.yml             </p><p>●   This command tells Ansible to use the specified inventory file and run the specified playbook.</p><p>Ansible connects to each node in turn, gathers facts, and then runs each task on each node. If a task is already in its desired state (for example, if the httpd package is already installed), Ansible skips it.</p><h2><a>My First Ansible Script</a></h2><p>To get started with Ansible, we need to create our first playbook. As mentioned, a playbook is a YAML file containing a series of tasks to be performed on managed nodes. For simplicity&#39;s sake, let us start by creating a playbook that installs the latest version of the Apache web server on our managed nodes.</p><p><a>Define Your Inventory</a></p><p>First, we need to define our inventory. In the simplest form, an inventory is a text file with a list of hostnames, one per line. Below is an example:</p><p><br/></p><p># inventory.txt 192.168.1.10</p><p>192.168.1.11</p><p># inventory.txt 192.168.1.10</p><p>192.168.1.11</p><p/><p># inventory.txt 192.168.1.10</p><p>192.168.1.11</p><p>This inventory file represents two nodes with the IP addresses 192.168.1.10 and 192.168.1.11.</p><p><a>Create the Playbook</a></p><p>Next, we create a playbook. Let us name it apache.yml. In this playbook, we define a single play that targets all nodes (hosts: all) and installs Apache (httpd package in most Linux distributions).</p><p><br/></p><p># apache.yml</p><p>---</p><p>- hosts: all become: yes tasks:</p><p>- name: Ensure Apache is installed package:</p><p>name: httpd</p><p>state: present</p><p># apache.yml</p><p>---</p><p>- hosts: all become: yes tasks:</p><p>- name: Ensure Apache is installed package:</p><p>name: httpd</p><p>state: present</p><p/><p># apache.yml</p><p>---</p><p>- hosts: all become: yes tasks:</p><p>- name: Ensure Apache is installed package:</p><p>name: httpd</p><p>state: present</p><p><br/></p><p>The become: yes line tells Ansible to execute the tasks with superuser privileges, as installing a package typically requires these.</p><p><a>Run the Playbook</a></p><p>We&#39;re now ready to run our playbook. Below is the command to do so:</p><p><br/></p><p>ansible-playbook     -i     inventory.txt     apache.yml             </p><p>This command tells Ansible to use the inventory.txt file we created earlier as the inventory and to run the apache.yml playbook. Ansible will then connect to each node, gather facts, and execute the tasks defined in the playbook.</p><p>If everything is set up correctly, Ansible will install Apache on all your nodes. If Apache is already installed, Ansible will recognize this and skip the task.</p><p>The above program demonstrates the core concepts of Ansible and you can continue to explore more complex tasks, using variables and roles, and managing more than just package installations.</p><h2><a>Trying out Complex Automation</a></h2><p>To further explore Ansible&#39;s capabilities, let us create a more complex playbook. This playbook will install and configure Apache to serve a simple HTML page.</p><p>Below is what we want our playbook to do:</p><p>●  Install Apache (as before)</p><p>●  Create an HTML file on the server</p><p>●  Modify the Apache configuration to serve this file</p><p>●  Restart Apache so the changes take effect Below is the playbook:</p><p>- hosts: all become: yes tasks:</p><p>- name: Ensure Apache is installed package:</p><p>name: httpd state: present</p><p>- name: Create a simple HTML file copy:</p><p>content: &quot;&lt;h1&gt;Welcome to our server!&lt;/h1&gt;&quot; dest: /var/www/html/index.html</p><p>- name: Ensure Apache serves our HTML file blockinfile:</p><p>path: /etc/httpd/conf/httpd.conf block: |</p><p>&lt;Directory &quot;/var/www/html&quot;&gt;</p><p>- hosts: all become: yes tasks:</p><p>- name: Ensure Apache is installed package:</p><p>name: httpd state: present</p><p>- name: Create a simple HTML file copy:</p><p>content: &quot;&lt;h1&gt;Welcome to our server!&lt;/h1&gt;&quot; dest: /var/www/html/index.html</p><p>- name: Ensure Apache serves our HTML file blockinfile:</p><p>path: /etc/httpd/conf/httpd.conf block: |</p><p>&lt;Directory &quot;/var/www/html&quot;&gt;</p><p/><p>- hosts: all become: yes tasks:</p><p>- name: Ensure Apache is installed package:</p><p>name: httpd state: present</p><p>- name: Create a simple HTML file copy:</p><p>content: &quot;&lt;h1&gt;Welcome to our server!&lt;/h1&gt;&quot; dest: /var/www/html/index.html</p><p>- name: Ensure Apache serves our HTML file blockinfile:</p><p>path: /etc/httpd/conf/httpd.conf block: |</p><p>&lt;Directory &quot;/var/www/html&quot;&gt;</p><p>Options Indexes FollowSymLinks AllowOverride None</p><p>Require all granted</p><p>&lt;/Directory&gt;</p><p>DocumentRoot &quot;/var/www/html&quot;</p><p>- name: Ensure Apache is running and enabled at boot service:</p><p>name: httpd state: started</p><p>enabled: yes</p><p>Options Indexes FollowSymLinks AllowOverride None</p><p>Require all granted</p><p>&lt;/Directory&gt;</p><p>DocumentRoot &quot;/var/www/html&quot;</p><p>- name: Ensure Apache is running and enabled at boot service:</p><p>name: httpd state: started</p><p>enabled: yes</p><p/><p>Options Indexes FollowSymLinks AllowOverride None</p><p>Require all granted</p><p>&lt;/Directory&gt;</p><p>DocumentRoot &quot;/var/www/html&quot;</p><p>- name: Ensure Apache is running and enabled at boot service:</p><p>name: httpd state: started</p><p>enabled: yes</p><p>Below is what each new task does:</p><p>●  The copy module creates a file at the specified dest path. The file&#39;s content is the value of the content parameter.</p><p>●  The blockinfile module inserts a block of text into a file. In this case, it&#39;s modifying the Apache configuration file to serve our HTML file.</p><p>●  The service module ensures a service is running and enabled to start at boot. In this case, it&#39;s making sure Apache is running and will start automatically if the server reboots.</p><p>To run this playbook, use the same command as before:</p><p><br/></p><p>ansible-playbook     -i     inventory.txt     apache.yml             </p><p>Now if you navigate to your nodes&#39; IP addresses in a web browser, you should see &quot;Welcome to our server!&quot;.</p><p>This playbook demonstrates Ansible&#39;s power to automate complex tasks. You can continue to add tasks to this playbook to further configure your servers, install additional software, or perform other administrative tasks.</p><h2><a>Using Playbook to Configure Servers</a></h2><p>To configure servers using the playbook, you need to target them in the inventory file. The inventory file is where you list all the servers (or &quot;nodes&quot;) you want to manage with Ansible.</p><p>Below is a simple example of an inventory file:</p><p><br/></p><p>[webservers] 192.0.2.1</p><p>192.0.2.2</p><p>[webservers] 192.0.2.1</p><p>192.0.2.2</p><p/><p>[webservers] 192.0.2.1</p><p>192.0.2.2</p><p><br/></p><p>In the above code snippet, webservers is a group that contains two nodes, identified by their IP addresses. You can also use hostnames if you prefer.</p><p>Now, update the hosts line in your playbook to target the webservers group:</p><p><br/></p><p>- hosts: webservers become: yes tasks:</p><p># ...</p><p>- hosts: webservers become: yes tasks:</p><p># ...</p><p/><p>- hosts: webservers become: yes tasks:</p><p># ...</p><p>With these changes, Ansible will run the playbook on all nodes in the webservers group when you use the ansible-playbook command:</p><p><br/></p><p>ansible-playbook    -i    inventory.txt    playbook.yml            </p><p>In this case, inventory.txt is the name of your inventory file, and playbook.yml is the name of your playbook file.</p><p>When you run this command, Ansible will connect to each node in the webservers group, perform the tasks defined in your playbook, and report the results. Remember, to connect to your nodes, Ansible needs appropriate SSH credentials. You can provide these by adding a remote_user and ansible_ssh_private_key_file to your inventory file, or by running Ansible from a user that has passwordless SSH access to your nodes. If you&#39;re using a user with sudo privileges (as indicated by become: yes in the playbook), Ansible will also need the sudo password. You can provide this with the --ask-become-pass or -K option when you run ansible- playbook.</p><p>Remember to replace the IPs with your actual server IPs and update the tasks according to your configuration needs. You can include multiple groups and nodes in the inventory file to manage a large number of servers. Also, make sure to use the correct file paths and names according to</p><p>your setup.</p><h2><a>Using Ansible for Managing Softwares</a></h2><p>You can use Ansible playbooks to manage software packages on your servers with the package management modules. Ansible has a module for most package managers on most Unix-like systems, including apt, yum, dnf, pkgng, etc. For our example, let us assume you are using a system with apt package manager, like Ubuntu.</p><p>The given below is a simple playbook that installs the nginx web server on all your web servers:</p><p><br/></p><p>- hosts: webservers become: yes tasks:</p><p>- name: Update apt cache apt:</p><p>update_cache: yes</p><p>- name: Install nginx apt:</p><p>name: nginx</p><p>state: present</p><p>- hosts: webservers become: yes tasks:</p><p>- name: Update apt cache apt:</p><p>update_cache: yes</p><p>- name: Install nginx apt:</p><p>name: nginx</p><p>state: present</p><p/><p>- hosts: webservers become: yes tasks:</p><p>- name: Update apt cache apt:</p><p>update_cache: yes</p><p>- name: Install nginx apt:</p><p>name: nginx</p><p>state: present</p><p>Below is what this playbook does:</p><p>●   The hosts: webservers line specifies that the playbook should run on all nodes in the webservers group.</p><p>●   The become: yes line tells Ansible to use sudo to execute the tasks. This is necessary because package management typically requires root privileges.</p><p>●  The tasks: line is followed by a list of tasks. Each task has a name that describes what it does, which is optional but recommended for readability.</p><p>●  The apt: line indicates that this task uses the apt module.</p><p>●   The update_cache: yes line tells the apt module to update the apt package cache before doing anything else. This is equivalent to running sudo apt update on the command line.</p><p>●  The name: nginx line specifies that the apt module should manage the nginx package.</p><p>●   The state: present line tells the apt module to ensure that nginx is installed. If nginx is not installed, the apt module will install it. If nginx is already installed, the apt module</p><p>will do nothing.</p><p>You can run this playbook with the ansible-playbook command, just like before:</p><p><br/></p><p>ansible-playbook    -i    inventory.txt    playbook.yml            </p><p>This command will install nginx on all nodes in the webservers group. If nginx is already installed, Ansible will ensure it&#39;s the latest version. If you want to install a specific version of a package, you can specify it using the = operator, e.g., name: nginx=1.14.0-0ubuntu1. Remember to replace the package name (nginx in the example) with the software you want to install.</p><h2><a>Summary</a></h2><p>In this chapter, we delved into Ansible, a popular open-source software tool for configuration management and automation. As a declarative IT automation platform, Ansible communicates with managed nodes and eliminates the need for dedicated remote systems. Built on Python, it uses YAML to express reusable descriptions of systems, making it versatile and straightforward to use, especially in network automation scenarios. We walked through the process of installing Ansible and setting it up in a Python environment, preparing the groundwork for more advanced operations.</p><p>We explored core Ansible concepts such as modules, tasks, and playbooks. Modules are units of code that Ansible executes, each designed for specific tasks. Tasks, on the other hand, are units of action in Ansible, while playbooks are the files where Ansible code is written. Playbooks, written in YAML, are human-readable, enabling easy orchestration of a multi-tier IT environment. We saw how to define and orchestrate simple automation using these concepts, providing a solid foundation for managing complex network configurations.</p><p>Finally, we used our knowledge of Ansible to execute more advanced operations, including server configuration and software installation using playbooks. By creating a playbook, we instructed Ansible to perform several tasks, including package updates and installation of new software on the target servers. This demonstrated Ansible&#39;s potential for simplifying and automating repetitive system administration tasks, freeing up resources for more strategic initiatives. Overall, Ansible&#39;s combination of simplicity, power, and wide community support makes it an excellent choice for network automation tasks.</p><h2><a>Index</a></h2><p><br/></p><h3>A</h3><p>aiohttp    119, 120, 121, 122, 123, 125</p><p>Ansible    i, 55, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164</p><p>Ansible Modules    154</p><p>APIs    99, 100, 101, 102, 104, 105, 106, 108, 110, 116, 125</p><p>Application Layer    38, 39, 40, 51</p><p>Application Layer Protocols    39, 40, 51</p><p>ARP    144</p><p>Async    113</p><p>Asynchronous Programming    113</p><p>AsyncIO    i, 112, 114, 115, 116, 118, 120</p><p>AsyncIO Library    114</p><h3>B</h3><p>Backup    55</p><p>Bandwidth    77, 80, 136</p><p>Bandwidth Usage    77, 80</p><p>BGP    144</p><p>Binding    26</p><h3>C</h3><p>Capacity Testing    128, 133</p><p>Configuration Backup    146</p><p>Configuration Management 54, 56, 143, 144, 149</p><p>Coroutines    114, 115</p><p><br/></p><h3>D</h3><p>Datagram    15, 19, 22, 23, 25, 36</p><p>Datagram Sockets    25</p><p>DDoS    79, 80</p><table><tr><td><p>Device Firmware</p></td><td><p><br/></p></td><td><p>65</p></td></tr><tr><td><p>Device-level APIs DHCP    17</p><p>distribution</p></td><td><p><br/></p><p>ii</p></td><td><p>102</p></td></tr></table><p>DNS    39, 40, 48, 49, 50, 51, 108, 110, 120, 143</p><p>DNS Queries    48</p><p><br/></p><h3>E</h3><p>Echo Server    116</p><p>Email    46, 108</p><p>Error Handling    49, 104</p><p>Ethernet    13, 78, 79</p><p>Event Loop    114</p><p><br/></p><h3>F</h3><p>File Transfer    15, 19, 39, 42, 51</p><p>Firewall    89</p><p>FTP    15, 19, 39, 42, 43, 44, 45, 51, 101, 121</p><p>FTPS    15</p><h3>H</h3><p>HTTP    15, 19, 39, 40, 41, 42, 51, 93, 101, 102, 104, 110, 120, 121, 122, 134</p><p>HTTPS    15, 39, 40, 51</p><h3>I</h3><p>ICMP    19, 81, 82, 95, 128, 129</p><p>IMAP    15, 19, 39, 45, 47, 51</p><p>Intrusion Detection    18, 94</p><p>Intrusion Detection System    18, 94</p><p>Intrusion Prevention System    18, 94</p><p>IP Address    17, 26, 91</p><p>IP Addressing    17</p><p><br/></p><h3>J</h3><p>Jitter    78, 82</p><p>JSON-RPC    101, 102</p><p><br/></p><h3>L</h3><p>LAN    13</p><p>Latency    78, 81, 85, 128</p><p>Locust    127, 131, 132, 133, 134</p><p><br/></p><h3>M</h3><p>Modules    11, 92, 154, 163</p><p><br/></p><h3>N</h3><p>NAPALM    54, 55, 144, 145, 146, 147, 148, 149</p><p>Netmiko    2, 54, 55, 56, 57, 58, 59, 61, 63, 64, 65, 67, 68, 144</p><p>Network Automation    53, 54, 55, 144, 149</p><p>Network Configuration Management    142, 143, 144, 149</p><p>Network Devices    54, 55</p><p>Network Infrastructure    139</p><table><tr><td><p>Network Map</p></td><td><p>90</p></td><td><p><br/></p></td></tr><tr><td><p>Network Monitoring</p></td><td><p><br/></p></td><td><p>19, 69, 70, 71, 108</p></td></tr><tr><td><p>Network Performance</p></td><td><p><br/></p></td><td><p>80, 83, 139</p></td></tr><tr><td><p>Network Programming</p></td><td><p><br/></p></td><td><p>112</p></td></tr><tr><td><p>Network Protocols</p></td><td><p><br/></p></td><td><p>14</p></td></tr><tr><td><p>Network Security</p></td><td><p><br/></p></td><td><p>18, 87, 88</p></td></tr><tr><td><p>Network Services</p></td><td><p><br/></p></td><td><p>54, 56, 99, 106</p></td></tr><tr><td><p>Network Testing</p></td><td><p><br/></p></td><td><p>126, 127</p></td></tr></table><p>Network Testing Methodologies    127</p><p>Network Traffic    77</p><p>Network Traffic Monitoring    77</p><p>Networking    i, 1, 2, 13, 19, 113, 120, 169</p><h3>O</h3><p>OSI Model    15</p><p><br/></p><h3>P</h3><p>Packet Loss    77, 81</p><p>PAN    13</p><p>Paramiko    2, 54, 57, 58, 59, 61, 67, 68</p><p>Performance Testing    128, 129</p><p>Ping    19, 71</p><p>Playbooks    154, 155, 164</p><p>POP3    39, 45</p><p>Port    26, 91</p><p>Prevention    94</p><p>prior    ii</p><p>PySNMP    71, 72, 75, 76, 85</p><p>Python    i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 19, 20, 22, 24, 25, 26, 27, 29, 32, 36, 40, 42, 45, 48, 49, 50, 51, 54, 55, 56, 57, 58,</p><p>59, 66, 67, 68, 71, 72, 75, 77, 78, 79, 80, 81, 82, 83, 85, 86, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 100, 101, 102, 103, 106,</p><p>107, 108, 109, 110, 113, 114, 115, 119, 120, 125, 127, 128, 129, 130, 131, 134, 135, 139, 144, 146, 149, 151, 152, 154, 163,</p><p>169</p><p><br/></p><h3>Q</h3><p>QoS    56, 140, 141</p><p><br/></p><h3>R</h3><p>Reliability Testing    128, 131</p><p>Remote Commands    63</p><p>REST APIs    101, 102</p><p>Routers    18</p><p>Routing    18, 56</p><h3>S</h3><p>Scalability    3</p><p>Scapy    71, 95, 96, 98, 127</p><p>SCP    66</p><p>Secure Communication    92</p><p>Secure Shell (SSH)    58</p><p>Sending and Receiving Data    28, 33</p><table><tr><td><p>Session</p></td><td><p>16</p></td></tr><tr><td><p>SFTP</p></td><td><p>15, 54, 57</p></td></tr><tr><td><p>Simpy</p></td><td><p>134</p></td></tr><tr><td><p>SMTP</p></td><td><p>15, 19, 39, 45, 46, 51, 101</p></td></tr><tr><td><p>SNMP</p></td><td><p>2, 71, 72, 74, 75, 76, 85</p></td></tr></table><p>SNMP Operations    72</p><p>SOAP APIs    101</p><p>Socket Errors    49, 50</p><p>Socket Programming    21, 24, 27, 32</p><p>SSH    54, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 152, 161</p><p>SSL    39, 40, 47, 92, 93, 97</p><p>SSL/TLS    92, 93, 97</p><p>Stream Sockets    25</p><p>Subnetting    17</p><p>Switches    18</p><p>Switching    18, 56</p><h3>T</h3><p>Tasks    114, 120, 154, 155, 163</p><p>TCP/IP    143</p><p>Throughput    78, 82, 83, 128</p><p>Timeouts    49</p><p>TLS    39, 40, 46, 92</p><p>Traceroute    19</p><p>Transport Layer    22, 39, 40, 92 Transport Layer Protocols    22</p><h3>U</h3><p>UDP    15, 19, 21, 22, 23, 24, 25, 26, 27, 32, 33, 34, 35, 36, 40, 48, 139</p><h3>V</h3><p>Version Control    146</p><p>VLAN    59, 60, 61</p><p>VPN    13, 56, 96, 97, 98</p><p>VPNs    18, 19, 20, 96, 98</p><p>Vulnerability    90</p><p><br/></p><h3>W</h3><p>WAN    13</p><p>Web Server    120, 122</p><p>Web Service    100</p><p>Wi-Fi    13</p><p>Wireshark    19, 20, 71</p><p><br/></p><h3>X</h3><p>XML-RPC    101, 102</p><p>XML-RPC and JSON-RPC    102</p><h2><a>Epilogue</a></h2><p>Congratulations on completing &quot;Python Networking 101&quot;! You have now acquired the knowledge and skills required to excel as a network administrator using Python. Throughout this book, you have learned about various networking tasks, Python libraries, and best practices that will enable you to design, implement, and maintain efficient networks. As you begin your journey as a network administrator, it is important to remember that the world of networking is constantly evolving. New technologies, best practices, and tools are continually being developed, making it crucial for you to stay informed and up-to-date. By keeping yourself aware of the latest advancements, you will be able to adapt and grow in your career as a network administrator.</p><p>The skills you have gained in this book, combined with your dedication to continuous learning, will ensure that you are well-equipped to handle the challenges that come your way in the world of networking. As you progress, you may also consider diving deeper into specialized areas of networking, such as cloud networking, software-defined networking (SDN), or network security. Each of these areas offers unique opportunities for growth and specialization.</p><p>We hope that &quot;Python Networking 101&quot; has provided you with a solid foundation and the confidence to tackle networking tasks using Python. As you continue to practice and refine your skills, you will find that Python&#39;s versatility and extensive library ecosystem make it an indispensable tool for network administration. In addition to the practical skills you have gained, remember that networking is also about building connections with people. Collaborate with your peers, share your knowledge, and engage with the networking community to expand your horizons and further your growth.</p><p>Thank you for choosing &quot;Python Networking 101&quot; as your guide on this exciting journey. We wish you the best of luck in your future endeavors as a skilled network administrator, and we hope that you will continue to explore, learn, and grow in the ever-evolving world of networking.</p><p><br/></p><p><a href="part11.htm">&lt; Назад</a> | <a href="index.html">Содержимое</a></p></body></html>
